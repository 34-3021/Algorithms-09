## 思路介绍

使用类似动态规划/状态机的思想。

计 $s$ 为 Reference 串，$t$ 为 Query 串。

状态 $f_{i,j}$ $(j\geq i)$ 表示 $s[0:i]$ 可以由**某些操作**得到 $t[0:j]$：

- 将 $s[a:b]$ 复制一份插入到 $s[b]$ 的位置。
- 将 $s[a:b]$ 复制一份，反转序列并按碱基互补的原则变换后，插入到 $s[b]$ 的位置。

存在状态转移（或称为有向边） $f_{i,j} \rightarrow f_{i,j+k}$ 当且仅当

- $s[i-k+1:i] = t[j+1:j+k]$ 或
- $s[i-k+1:i]$ 经过反转和互补后等于 $t[j+1:j+k]$。

存在状态转移 $f_{i,j} \rightarrow f_{i+1,j+1}$ 当且仅当 $s[i+1] = t[j+1]$。

最终状态 $f_{n-1,m-1}$ 即为从 $f_{0,0}$ 经过若干状态转移得到的状态。

## 时间复杂度

使用哈希的方式进行字符串比对，时间复杂度 $\Theta(1)$，预处理复杂度 $\Theta(m+n)$。

每个状态至多只会访问一次，状态被访问的次数 $O((m-n)n)$ 考虑到有些状态无论如何不会被访问。

> 此处用 $O$ 表示是因为具体复杂度取决于输入的性质。

每个状态会尝试所有的 $k$，$k$ 的上界为 $n$，所以总的时间复杂度为 $O((m-n)n^2)$。

## 空间复杂度

哈希，空间复杂度 $\Theta(m+n)$。
存储每个状态以及状态的来源，空间复杂度 $O((m-n)n)$。