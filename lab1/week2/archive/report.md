## 题目描述

计 $s$ 为 Reference 串，$t$ 为 Query 串。

状态 $f_{i,j}=1$ $(j\geq i)$ 表示 $s[0:i]$ 可以经过若干次**以下操作**得到 $t[0:j]$：

- 将 $s[a:b]$ （其必须来源于原始的串，而不能是由先前的操作生成的）复制一份插入到 $s[b]$ 之后。
- 将 $s[a:b]$ （其必须来源于原始的串，而不能是由先前的操作生成的）复制一份，反转序列并按碱基互补的原则变换后，插入到 $s[b]$ 之后。

因此存在状态转移（或称为有向边）：

- $f_{i,j} \rightarrow f_{i,j+k}$ 当且仅当
  - $s[i-k+1:i] = t[j+1:j+k]$ 或
  - $s[i-k+1:i]$ 经过反转和互补后等于 $t[j+1:j+k]$。

- $f_{i,j} \rightarrow f_{i+1,j+1}$ 当且仅当
  - $s[i+1] = t[j+1]$。

最终状态 $f_{n-1,m-1}$ 即为从 $f_{0,0}$ 经过若干状态转移得到的状态。

数据保证一定有由 $f_{0,0}$ 到 $f_{n-1,m-1}$ 的路径。由于由 $f_{0,0}$ 到 $f_{n-1,m-1}$ 可能有多种路径，请输出一条最短路径。

## 输入数据

2 行，每行一个字符串，分别表示 $s$ 和 $t$。

## 输出数据

若干行，每行两个整数 $i$ $j$ 用空格隔开，表示**倒序**路径上的状态。

其中第一行必须为 `0 0`，最后一行必须为 `n-1 m-1`。

## 伪代码

`HASH (s, t)` 表示将字符串 $s$ 和 $t$ 转换为哈希值。

`REV(s)` 表示进行碱基互补和反转的操作。

以上两个操作不再赘述其具体实现。

以下仅对核心部分进行处理

- $f[m][n]$ and $f\_ from[m][n]$ are arrays initialized to 0.
- $f[0][0] \leftarrow 1$
- $q$ is a queue initialized to empty.
- $q$ $\leftarrow$ $(0, 0)$
- while $q$ is not empty do
    - $(i, j)$ $\leftarrow$ front of $q$
    - pop $q$
    - if $s[i+1] = $t[j+1]$ then
        - $f[i+1][j+1] \leftarrow 1$
        - $f\_ from[i+1][j+1] \leftarrow (i, j)$
        - $q$ $\leftarrow (i+1, j+1)$
    - for k in range(2, m):
        - if `HASH`($s[i-k+1:i]$) = `HASH`($t[j:j+k]$) or `HASH`(`REV`($s[i-k+1:i]$)) = `HASH`($t[j:j+k]$):
            - $f[i][j+k] \leftarrow 1$
            - $f\_ from[i][j+k] \leftarrow (i, j)$
            - $q$ $\leftarrow (i, j+k)$


## 时间复杂度

使用哈希的方式进行字符串比对，时间复杂度 $\Theta(1)$，预处理复杂度 $\Theta(m+n)$。

每个状态至多只会访问一次，状态被访问的次数 $O((m-n)n)$ 考虑到有些状态无论如何不会被访问。

> 此处用 $O$ 表示是因为具体复杂度取决于输入的性质。

每个状态会尝试所有的 $k$，$k$ 的上界为 $n$，所以总的时间复杂度为 $O((m-n)n^2)$。

**需要注意，这个 $O$ 是一个非常宽松的上界，实际运行时的复杂度一定会更低，对于一个正常的运行，其应当基本为线性复杂度。**


**即使对于精心构造的数据，即存在多种方法到达一个状态，这种情况下可以直接考虑到达终点的最短路径，而不是考虑所有的路径。**

## 空间复杂度

哈希，空间复杂度 $\Theta(m+n)$。
存储每个状态以及状态的来源，空间复杂度 $O((m-n)n)$。