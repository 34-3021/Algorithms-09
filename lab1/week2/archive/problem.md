## 题目描述

计 $s$ 为 Reference 串，$t$ 为 Query 串。

状态 $f_{i,j}=1$ $(j\geq i)$ 表示 $s[0:i]$ 可以经过若干次**以下操作**得到 $t[0:j]$：

- 将 $s[a:b]$ （其必须来源于原始的串，而不能是由先前的操作生成的）复制一份插入到 $s[b]$ 之后。
- 将 $s[a:b]$ （其必须来源于原始的串，而不能是由先前的操作生成的）复制一份，反转序列并按碱基互补的原则变换后，插入到 $s[b]$ 之后。

因此存在状态转移（或称为有向边）：

- $f_{i,j} \rightarrow f_{i,j+k}$ 当且仅当
  - $s[i-k+1:i] = t[j+1:j+k]$ 或
  - $s[i-k+1:i]$ 经过反转和互补后等于 $t[j+1:j+k]$。

- $f_{i,j} \rightarrow f_{i+1,j+1}$ 当且仅当
  - $s[i+1] = t[j+1]$。

最终状态 $f_{n-1,m-1}$ 即为从 $f_{0,0}$ 经过若干状态转移得到的状态。

数据保证一定有由 $f_{0,0}$ 到 $f_{n-1,m-1}$ 的路径。由于由 $f_{0,0}$ 到 $f_{n-1,m-1}$ 可能有多种路径，请输出一条最短路径。

## 输入数据

2 行，每行一个字符串，分别表示 $s$ 和 $t$。

## 输出数据

若干行，每行两个整数 $i$ $j$ 用空格隔开，表示路径上的状态。

其中第一行必须为 `0 0`，最后一行必须为 `n-1 m-1`。

## 输入样例

```plaintext
AGCAGCT
AGCAGCAGCT
```

## 输出样例

```plaintext
0 0
1 1
2 2
2 5
3 6
4 7
5 8
6 9
```
解释：
其中 $s[0:2]=t[3:5]$

## 输入样例

```plaintext
AGCAGCT
AGCAGCGCAGCCAGCT
```

## 输出样例

```plaintext